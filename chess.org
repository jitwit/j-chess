#+title: Chess from J
#+subtitle: idk
#+OPTIONS: author:nil num:nil
#+HTML_HEAD: <link rel="stylesheet" href="../format/css.css" />
#+HTML_HEAD: <link rel="icon" type="image/png" href="../images/icon.png" />


* Representation

** bitboard/state

Letters for pieces and a starting board. The representation:
+ 2x6 table of 8x8 bitboards for each color for each piece. The first
  item of the table represents black's position and the last item
  white's. 
+ The player's move is an index 0 or 1 into that bitboard table,
  starting at 1 for white to move.
+ Castling rights are indicated with a length for array for white's
  king & queen sides then black's king & queen sides rights.
+ En passant is represented by a column (0-7). Based on whose turn it
  is this is sufficient to determine the target square, as the only
  moves when pawn's advance by 2 are rows 2->4 or 7->5. No enpassant
  target is indicated by the number 8.
+ Half move clock is a number (the moves since last capture or pawn move).
+ Full move clock is a number that increments after moves by black.

#+name: basics
#+begin_src J :session :exports code
pieces =: 'pnbrqkPNBRQK'

board0 =: (];._2) 0 : 0
rnbqkbnr
pppppppp
........
........
........
........
PPPPPPPP
RNBQKBNR
)

start =: (_6 ]\ pieces ="0 _ board0);1;1 1 1 1;8;0;1
print =: ('.',pieces) {~ +./ @: (* 1+i.@#) @: (,/)
#+end_src

#+RESULTS: basics
: 2 6 8 8

We can see the boards with the help of ~print~:

#+begin_src J :session :exports results :verb 0!:1
<"0 print 0 {:: start
#+end_src

#+RESULTS:
#+begin_example
   <"0 print 0 {:: start
┌─┬─┬─┬─┬─┬─┬─┬─┐
│r│n│b│q│k│b│n│r│
├─┼─┼─┼─┼─┼─┼─┼─┤
│p│p│p│p│p│p│p│p│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│P│P│P│P│P│P│P│P│
├─┼─┼─┼─┼─┼─┼─┼─┤
│R│N│B│Q│K│B│N│R│
└─┴─┴─┴─┴─┴─┴─┴─┘
#+end_example

** squares

~IP, ..., IK~ give some kind of enumeration of the indices for the
various piece bitboards. ~coords~ give the algebraic ascii values for
columns and rows. ~square~ takes a description for a square and
returns its index in an 8x8 grid.

#+name: squares
#+begin_src J :session :exports both
'IP IN IB IR IQ IK' =: i. 6
coords =: 97 (,:|.)&(a.{~+&(i.8)) 49
squareix =: [: |. coords&(i."1 0)

movesto =: _2 {. -.&((6}.pieces),'+#=')
square =: (i. 8 8) = 8 #. squareix @: movesto
#+end_src

#+RESULTS:
: abcdefgh
: 87654321

** movement

Here are neighborhoods for all the pieces, described as vectors.

#+name: neighborhoods
#+begin_src J :session :exports both
NP =: (,-) 2 0,1,.i:1 NB. pawn (both black & white)
NN =: ,/ (<:+:#:i.4) *"1/ >:=/~i.2 NB. knight
NB =: ,/ (<:+:#.^:_1 i.4) *"1/ ,~"0}.i.8 NB. bishop
NR =: (,-) (,.&0,0&,.) }. i.8 NB. rook
NQ =: NB,NR NB. queen
NK =: <: 3 #.^:_1 (i.9)-.4 NB. king
NHOOD =: NP;NN;NB;NR;NQ;NK
#+end_src

For example:

#+begin_src J :session :exports results :verb 0!:1
NN NB. knight moves
NN (+:@] + +./@:(|.!.0)) square 'b5' NB. knight's moves from b5
#+end_src

#+RESULTS:
#+begin_example
   NN NB. knight moves
_2 _1
_1 _2
_2  1
_1  2
 2 _1
 1 _2
 2  1
 1  2
   NN (+:@] + +./@:(|.!.0)) square 'b5' NB. knight's moves from b5
0 0 0 0 0 0 0 0
1 0 1 0 0 0 0 0
0 0 0 1 0 0 0 0
0 2 0 0 0 0 0 0
0 0 0 1 0 0 0 0
1 0 1 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
#+end_example

* FEN

It's (clearly) useful to be able to input and output postions in FEN
format. FEN encodes positions with a string describing the board rank
by rank, from the 8th forward separated by ~/~, with lower case for
black, upper case for white, with empty spaces encoded by
numbers. Turn indicated by ~b | w~, castling rights with chars ~KQkq~,
en passant target square, half moves & full moves. The absence of
castling rights or en passant squares is shown via a dash ~-~.

#+name: fen
#+begin_src J :session :exports both
NB. FEN helpers
rleb =. (0&{::#1&{::)`([:":0&{::)@.('.'-:1&{::)
rldb =. ]`('.'#~".)@.(e.&({:coords))
rle =. ([: < [: rleb (#;{.));.1~ 1,2 ~:/\ ]
rld =. [: ([:;<@rldb"0);._1 '/',]
efen =. [: > [: (([,'/',])&.>)/ [: <@;@rle"1 print
dfen =. (_6]\i.#pieces) =/ pieces i. rld

fen_of =: 3 : 0
 NB. fen from our representation
 'brd bw oo ep hm fm' =. y
 oo =. (0<+/oo){::'-';oo#'KQkq'
 ep =. (ep~:8){::'-';(ep{({.coords),'-'),(bw{'36')
 ;:^:_1 (efen brd);(bw{'bw');oo;ep;hm;&":fm
)

pos_of =: 3 : 0
 NB. our representation from a fen
 'brd bw oo ep hm fm' =. <;._1 ' ',y
 NB. careful that bw isn't array?
 (dfen brd);('w'={.bw);('KQkq'e.oo);({:(squareix :: 8:)ep);hm;&".fm
)

NB. fen to encode, fen^:_1 to decode
fen =: fen_of :. pos_of
#+end_src

#+RESULTS: fen

#+begin_src J :session :exports results :verb 0!:1
fen start
start -: ]&.:fen start
#+end_src

#+RESULTS:
:    fen start
: rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
:    start -: ]&.:fen start
: 1

* Final program

#+begin_src J :session :tangle chess-chess.ijs :noweb yes
coclass 'jchess'
<<basics>>

<<squares>>

<<neighborhoods>>

<<fen>>
#+end_src
