#+title: Chess from J
#+subtitle: idk
#+OPTIONS: author:nil num:nil
#+HTML_HEAD: <link rel="stylesheet" href="../format/css.css" />
#+HTML_HEAD: <link rel="icon" type="image/png" href="../images/icon.png" />


* Representation

** bitboard/state

Letters for pieces and a starting board. The representation:
+ 2x6 table of 8x8 bitboards for each color for each piece. The first
  item of the table represents black's position and the last item
  white's. 
+ The player's move is an index 0 or 1 into that bitboard table,
  starting at 1 for white to move.
+ Castling rights are indicated with a length for array for white's
  king & queen sides then black's king & queen sides rights.
+ En passant is represented by a column (0-7). Based on whose turn it
  is this is sufficient to determine the target square, as the only
  moves when pawn's advance by 2 are rows 2->4 or 7->5. No enpassant
  target is indicated by the number 8.
+ Half move clock is a number (the moves since last capture or pawn move).
+ Full move clock is a number that increments after moves by black.

#+name: basics
#+begin_src J :session :exports code
pieces =: 'pnbrqkPNBRQK'
piecesfr =: 'pcftdrPCFTDR'
pieces_u =: u: (i.-#pieces) + 16b2654 NB. unicode, nb width screws up boxing

board0 =: (];._2) 0 : 0
rnbqkbnr
pppppppp
........
........
........
........
PPPPPPPP
RNBQKBNR
)

start =: (_6 ]\ pieces ="0 _ board0);1;1 1 1 1;8;0;1
print =: ('.',pieces) {~ +./ @: (* 1+i.@#) @: (,/)
display =: print @: bits
bits =: 0&{:: NB. the bit grid
isw =: 1&{:: NB. the is white flag
enpf =: 3&{:: NB. en passant file flag (8 means none, otherwise indicates file)
#+end_src

#+RESULTS: basics

We can see the boards with the help of ~print~:

#+begin_src J :session :exports results :verb 0!:1
<"0 print 0 {:: start
#+end_src

#+RESULTS:
#+begin_example
   <"0 print 0 {:: start
┌─┬─┬─┬─┬─┬─┬─┬─┐
│r│n│b│q│k│b│n│r│
├─┼─┼─┼─┼─┼─┼─┼─┤
│p│p│p│p│p│p│p│p│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│P│P│P│P│P│P│P│P│
├─┼─┼─┼─┼─┼─┼─┼─┤
│R│N│B│Q│K│B│N│R│
└─┴─┴─┴─┴─┴─┴─┴─┘
#+end_example

** squares

~IP, ..., IK~ give some kind of enumeration of the indices for the
various piece bitboards. ~coords~ give the algebraic ascii values for
columns and rows. ~square~ takes a description for a square and
returns its index in an 8x8 grid.

#+name: squares
#+begin_src J :session :exports both
'IP IN IB IR IQ IK' =: i. 6
coords =: 97 (,:|.)&(a.{~+&(i.8)) 49
squareix =: [: |. coords&(i."1 0)

movesto =: _2 {. -.&((6}.pieces),'+#=') NB. should be in algebraic notation section?
square =: (i. 8 8) = 8 #. squareix @: movesto
sq =: square
NB. x clr y (clear square x in bit grid y, x given as coordinate string)
clr =: (-. @: sq @: [) *."2 ]
#+end_src

#+RESULTS: squares

#+RESULTS:
: abcdefgh
: 87654321

** movement

Here are neighborhoods for all the pieces, described as vectors.

#+name: neighborhoods
#+begin_src J :session :exports both
NP =: (,-) 2 0,1,.i:1 NB. pawn (both black & white)
NN =: ,/ (<:+:#:i.4) *"1/ >:=/~i.2 NB. knight
NB =: ,/ (<:+:#.^:_1 i.4) *"1/ ,~"0}.i.8 NB. bishop
NR =: (,-) (,.&0,0&,.) }. i.8 NB. rook
NQ =: NB,NR NB. queen
NK =: <: 3 #.^:_1 (i.9)-.4 NB. king
NHOOD =: NP;NN;NB;NR;NQ;NK

DP =: _1 ^ 1 + isw NB. direction of pawn movement based on color for use with |.
enp =: (i. 8 8) = 8 #. enpf ,~ 2 + 3 * 1 - isw NB. doesn't validate enpf not 8
#+end_src

#+RESULTS: neighborhoods

For example:

#+begin_src J :session :exports results :verb 0!:1
NN NB. knight moves
<"0 ' x@' {~ NN (+:@] + +./@:(|.!.0)) square 'b5' NB. knight's moves from b5
#+end_src

#+RESULTS:
#+begin_example
   NN NB. knight moves
_2 _1
_1 _2
_2  1
_1  2
 2 _1
 1 _2
 2  1
 1  2
   <"0 ' x@' {~ NN (+:@] + +./@:(|.!.0)) square 'b5' NB. knight's moves from b5
┌─┬─┬─┬─┬─┬─┬─┬─┐
│ │ │ │ │ │ │ │ │
├─┼─┼─┼─┼─┼─┼─┼─┤
│x│ │x│ │ │ │ │ │
├─┼─┼─┼─┼─┼─┼─┼─┤
│ │ │ │x│ │ │ │ │
├─┼─┼─┼─┼─┼─┼─┼─┤
│ │@│ │ │ │ │ │ │
├─┼─┼─┼─┼─┼─┼─┼─┤
│ │ │ │x│ │ │ │ │
├─┼─┼─┼─┼─┼─┼─┼─┤
│x│ │x│ │ │ │ │ │
├─┼─┼─┼─┼─┼─┼─┼─┤
│ │ │ │ │ │ │ │ │
├─┼─┼─┼─┼─┼─┼─┼─┤
│ │ │ │ │ │ │ │ │
└─┴─┴─┴─┴─┴─┴─┴─┘
#+end_example

** Sliding Movement
#+name: sliding-movement
#+begin_src J :session :exports both
NB. n is source, m is mask of clear squares?
MV =: {{ (+. m *. y&(|.!.0))^:_ n }} NB. moves
ATK =: {{ n ~: y |.!.0 m MV n y }} NB. attacks (moves including possibly one piece)
NB. y is source square, m is movement vector, x is bit brick
NB. thus, in MV/ATK, n is source, m is clear squares, y is movement direction
ATK1 =: {{ y |.!.0 n }} NB. attacks (moves including possibly one piece)
M =: {{ y ~: +./ _2 (y ~: -. +./^:2 x) MV y\ m }}
A =: {{ y ~: +./ _2 (y ~: -. +./^:2 x) ATK y\ m }}
A1 =: 2 : '+./ (_2 ]\ m) |.!.0 y'
NB. A1 =: {{ y ~: +./ _2 (y ~: -. +./^:2 x) ATK1 y\ m }} M1 =: {{ y ~:
NB. +./ _2 (y ~: -. +./^:2 x) MV y\ m }} NB. move single square
MB =: _1 _1 _1 1 1 _1 1 1 M NB. bishop
AB =: _1 _1 _1 1 1 _1 1 1 A NB. bishop
MR =: 0 _1 0 1 _1 0 1 0 M NB. rook
AR =: 0 _1 0 1 _1 0 1 0 A NB. rook
AK =: (,NK) A1 NB. king
AN =: (,NN) A1 NB. knight
MQ =: MB +. MR
AQ =: AB +. AR
#+end_src

#+RESULTS: sliding-movement

* Algebraic Notation

This a most annoying thing to get working. Chess moves are described
by giving the piece and the square it moves to. Pawns moves are
implicitly given by just the square. If only one piece can move to the
square, then the source is not indicated. If there is ambiguity then
more information about the source is given, the source file, rank, or
even the full source square if file or rank alone would still be
ambiguous.

The grammar is (roughly):

#+begin_example
piece = N | B | R | Q | K
file = a | b | c | d | e | f | g | h
rank = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8
capture = x
check = +
checkmate = #
kingattack = check | checkmate
square = file rank
promotion = '='
castle = (O-O | O-O-O) kingattack?
move = (piece? file? rank? capture? square (promotion piece)? kingattack?)
     | castle
#+end_example

** masks

As we use bitboards, here are some verbs to get masks files, ranks,
and getting the piece from a move.

A source of a bug was confusion of file b with bishop; it's important
to only look for capital letters for describing pieces in moves.

Mask from takes a move in algebraic notation and gives a mask for
where the piece could have come from.

#+name: masks
#+begin_src J :session :exports both
piece =: [: (* 6&~:) (6}.pieces) i. {.
maskf =: (8 8 $ i.8) = ({.coords)&i. NB. mask file
maskr =: (8 $"0 i.8) = ({:coords)&i. NB. mask row
maskc =: maskr`maskf@.(e.&'abcdefgh') NB. for masking eg Nbxd2 or R3a2

maskm =: 4 : 0
 to =. (i. 8 8) = 8 #. squareix d =. _2 {. z =. y -. (6}.pieces),'x+#='
 select. who =. piece y
 case. IR do. (who {"_1 x) *."2 (+./^:2 x) AR to
 case. IB do. (who {"_1 x) *."2 (+./^:2 x) AB to
 case. IQ do. (who {"_1 x) *."2 (+./^:2 x) AQ to
 case. IP do. (maskf {.y) *"2 (_4 +./\ NP |.!.0 to)
 case. do. (*/maskc _2}.z) * +./ (who{::NHOOD)|.!.0 to end.
)

NB. have a target square, figure out which piece can get there.
maskfrom =: 3 : 0
 msk =. (i. 8 8) = 8 #. squareix d =. _2 {. z =. y -. (6}.pieces),'x+#='
 p =. piece y  NB. pawn = 0, so if. works
 if. p do. ,:~ (*/maskc _2}.z) * +./ (p{::NHOOD)|.!.0 msk
 else. (maskf {.y) *"2 (_4 +./\ NP |.!.0 msk) end.
)
#+end_src

#+RESULTS: masks

** disambiguation

Sometimes two pieces can move to the same square, if not for some
other pieces in the way. Algebraic notation leaves these situations
ambiguous, so sometimes ~maskfrom~ is insufficient for figuring out
the source of a move.

#+name: disambiguation
#+begin_src J :session :exports both
disamb =: 3 : 0
 'brd clr to' =. y
 pcs =. +./^:2 brd
 z_t =. {.4$.$.to NB. only 1 square here
 z_s =. 4$.$.clr
 tab =. z_t -"1/~ z_s
 mag =. >./"1 | tab
 dir =. * tab
 src =. z_s #~ 1 = dir ([: +/ pcs {~ [: <"1 z_t +"1 (1+i.@]) */ [)"1 0 mag
 (i.8 8) = 8 #. {.src
)

disambe =: disamb :: {{ a: [ echo y }}
#+end_src

#+RESULTS: disambiguation

** castling

#+name: castling
#+begin_src J :session :exports both
NB. x = 0 or 1 means king or queen sides resp, y is position
castle =: 4 : 0
 'brd bw oo ep hm fm' =. y
 oo =. oo * (-+:<:+:bw) |.!.0 oo
 if. x do. if. bw do. 'k r' =. 'c1';'a1d1' else. 'k r' =. 'c8';'a8d8' end.
 else.     if. bw do. 'k r' =. 'g1';'f1h1' else. 'k r' =. 'g8';'f8h8' end.
 end.
 rm =. (+./ _2 square\ r) ~: (<bw,IR) { brd
 brd =. ((square k),:rm)((<bw,IK),(<bw,IR))}brd
 brd;(-.bw);oo;ep;(hm+1);(fm+-.bw)
)
castleq =: 1&castle
castlek =: 0&castle
#+end_src

#+RESULTS: castling

** SAN mostrosity

The following mostrosity takes a move and a position and produces a
new position. Little error checking is currently done, it is (for the
moment) assumed the input pgn/move/state is valid and consistent.

#+name: san-monstrosity
#+begin_src J :session :exports both
san =: 4 : 0
 NB. produces resulting position with arguments x as move in SAN, y as
 NB. position in J representation.
 if. 'O-O-O' -: 5{.x   do. 1 castle y NB. {. to avoid possible +/#
 elseif. 'O-O' -: 3{.x do. 0 castle y
 else.  'brd bw oo ep hm fm' =. y [ p =. piece x
  clr =. (bw{p{"_1 brd)*bw{brd maskm x
  to =. square x
  if. 1 < +/,clr do. clr =. disamb brd;clr;to end.
  clr =. clr + to
  to =. ,:~ (p=i.6) */ to
  brd1 =. ((bw=i.2) * to) + (-.clr) *"2 brd
  if. '=' e. x  NB. promotion  
  do. brd1=.(square x)(<bw,piece{:x-.'+#x')}(-.pr=.square x)*"2 brd1 end.
  NB. en passant
  epr =. I. +/"1 epb =. | +/ IP {"_1 diff =. brd1 - brd
  NB. castling rights
  oo =. oo * -.,_3 (2+./\])\ (_2 <@squareix\ 'h1e1a1h8e8a8') { +./^:2 | diff
  if. (-.p) *. (2=-~/epr) *. (*#epr) do. ep =. >./ I. epb else. ep =. 8 end.
  NB. half moves/full moves
  fm =. fm+-.bw [ hm =. (hm+1) * -. (-.({.x)e.pieces) +. ('x'e.x)
  brd1;(-.bw);oo;ep;hm;fm
 end.
)

NB. have a target square, figure out which piece can get there.
SAN =: 4 : 0
NB. fix: check castling first, as piece returns pawn for those moves.
 p =. piece x
 'brd bw oo ep hm fm' =. y
 brdc =. brd
 NB. to : where piece will be
 to =. (i. 8 8) = 8 #. xy =. squareix d =. _2 {. z =. x -. (6}.pieces),'x+#='
 select. p
 case. IP do.
   dz =. 0,~<:+:bw
   ept =. ep ,~ 2 + 3 * 1 - bw NB. en passant target index
   NB. simple pawn moves, also need to do captures & promotions
   if. 'x' e. x NB. if capture
   do. src =. (i. 8 8) = 8 #. dz+({.xy),({.coords)i.{.z NB. source
       NB. square extra clear bit in case en passant for captured
       NB. pawn
       capenp =. (xy-:ept) *. (i. 8 8) = 8#.xy+dz 
       brd =. ((-.src)*.to+.(<bw,p){brd) (<bw,p)} brd*."2-.src+.capenp
       ep =. 8 NB. no en passant when capturing
   else.
    is2 =. -.(<bw,0,dz+xy){brd NB. if no pawn was a 2 step move
    src =. (i. 8 8) = 8#.xy+dz+is2*dz NB. source square
    ep =. is2{8,{:xy NB. en passant if moved 2 on file ({:xy), else 8
    brd =. ((-.src)*.to+.(<bw,p){brd) (<bw,p)} brd*."2-.src
   end.
   if. '=' e. x NB. promotion
   do. brd=.(to+.pix{brd) (pix=.<bw,piece{:x-.'+#x')} (-.to)*."2 brd 
   end.
 case. IN do. NB. fixme, check and filter if still ambiguous here...
   src =. ((<bw,p){brd) *. (*./maskc _2}.z) *. brd AN to
   brd =. ((-.src)*.to+.(<bw,p){brd) (<bw,p)} brd*."2-.to+.src
 case. IB do. NB. fixme, check and filter if still ambiguous here...
   src =. ((<bw,p){brd) *. (*./maskc _2}.z) *. brd AB to
   brd =. ((-.src)*.to+.(<bw,p){brd) (<bw,p)} brd*."2-.to+.src
 case. IR do. NB. fixme, check and filter if still ambiguous here...
   src =. ((<bw,p){brd) *. (*./maskc _2}.z) *. brd AR to
   brd =. ((-.src)*.to+.(<bw,p){brd) (<bw,p)} brd*."2-.to+.src
 case. IQ do. NB. fixme, check and filter if still ambiguous here...
   src =. ((<bw,p){brd) *. (*./maskc _2}.z) *. brd AQ to
   brd =. ((-.src)*.to+.(<bw,p){brd) (<bw,p)} brd*."2-.to+.src
 case. IK do. NB. fixme, check and filter if still ambiguous here...
   src =. ((<bw,p){brd) *. (*./maskc _2}.z) *. brd AK to
   brd =. ((-.src)*.to+.(<bw,p){brd) (<bw,p)} brd*."2-.to+.src
 end.
 NB. castling
 oo =. oo * -.,_3 (2+./\])\ (_2 <@squareix\ 'h1e1a1h8e8a8') { +./^:2 brd ~: brdc
 fm =. fm+-.bw [ hm =. (hm+1) * -. (-.({.x)e.pieces) +. ('x'e.x)
 brd;(-.bw);oo;ep;hm;fm
)

#+end_src

#+RESULTS: san-monstrosity

For example some Blackmar-Diemer-Ryder:

#+begin_src J :session :exports results :verb 0!:1
<"0 print 0 {:: 'Qxd4' san 'Qxf3' san 'exf3' san 'f3' san 'Nf6' san 'Nc3' san 'dxe4' san 'd4' san 'd5' san 'e4' san start
#+end_src

#+RESULTS:
#+begin_example
   <"0 print 0 {:: 'Qxd4' san 'Qxf3' san 'exf3' san 'f3' san 'Nf6' san 'Nc3' san 'dxe4' san 'd4' san 'd5' san 'e4' san start
┌─┬─┬─┬─┬─┬─┬─┬─┐
│r│n│b│q│k│b│n│r│
├─┼─┼─┼─┼─┼─┼─┼─┤
│p│p│p│.│p│p│p│p│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│n│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│q│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│N│.│.│Q│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│P│P│P│.│.│.│P│P│
├─┼─┼─┼─┼─┼─┼─┼─┤
│R│N│B│Q│K│B│N│R│
└─┴─┴─┴─┴─┴─┴─┴─┘
#+end_example

* PGN

Need to figure out all what I'd like to be able to do with pgns, but
for now we can take the move part of the PGN and get all the positions
of a game.

#+name: pgn
#+begin_src J :session :exports both
del_brak =: ] #~ 0 = [: (+. _1&(|.!.0)) [: +/\ (-/@:(=/))
del_com =: (-.&'?!')&.>
del_num =: #~ ('.' ~: {:)&>
pgn_clean =: {{ '()' del_brak '{}' del_brak ' ' (I. LF=y)} y }}
pgn_nonmoves =: a:,'1-0';'0-1';'1/2-1/2'
pgn_moves =: {{ del_num del_com (<;._1 ' ',pgn_clean y) -. pgn_nonmoves }}

NB. x =. x -. '?! ' NB. remove move quality commentary
game_of_pgn =: 3 : 0
 moves =. pgn_moves y
 fens =. < brd =. start
 for_move. moves do.
   fens =. fens,<brd =. (>move) san brd
 end.
)

pgn_key =: > @: {. @: (<;._1)~ '[ '&(+./ @: (=/)) NB. pgn symbol token
pgn_val =: #~ [: (~:/\ * 0&=) '"'&= NB. pgn string token
pgn_db =: <;.1~ '[Event'&E.
pgn_moves_sec =: I. @: ((LF,'1.')&E.)

ppgn =: 3 : 0
NB. remove abandoned?
 j =. {. (<:#y),~pgn_moves_sec y=.y,LF
 tagpairs =. (pgn_key;pgn_val);._2 j {. y
 movetext =. (j }. y) -. LF
 tagpairs ; movetext
)
#+end_src

#+RESULTS: pgn

* DB

#+name: db
#+begin_src J :session :exports both

#+end_src

* FEN

It's (clearly) useful to be able to input and output postions in FEN
format. FEN encodes positions with a string describing the board rank
by rank, from the 8th forward separated by ~/~, with lower case for
black, upper case for white, and empty space encoded by the number of
consecutive empty squares. Turn is indicated by ~b | w~, castling
rights by ~KQkq~. There is a possible en passant target square, and
lastly half moves & full moves. The absence of castling rights or en
passant squares is given by ~-~.

#+name: fen
#+begin_src J :session :exports both
NB. FEN helpers
rleb =: (0&{::#1&{::)`([:":0&{::)@.('.'-:1&{::)
rldb =: ]`('.'#~".)@.(e.&({:coords))
rle =: ([: < [: rleb (#;{.));.1~ 1,2 ~:/\ ]
rld =: [: ([:;<@rldb"0);._1 '/',]
efen =: [: > [: (([,'/',])&.>)/ [: <@;@rle"1 print
dfen =: (_6]\i.#pieces) =/ pieces i. rld

fen_of =: 3 : 0
 NB. fen from our representation
 'brd bw oo ep hm fm' =. y
 oo =. (0<+/oo){::'-';oo#'KQkq'
 ep =. (ep~:8){::'-';(ep{({.coords),'-'),(bw{'36')
 ;:^:_1 (efen brd);(bw{'bw');oo;ep;hm;&":fm
)

pos_of =: 3 : 0
 NB. our representation from a fen
 'brd bw oo ep hm fm' =. <;._1 ' ',y
 NB. careful that bw isn't array?
 (dfen brd);('w'={.bw);('KQkq'e.oo);({:(squareix :: 8:)ep);hm;&".fm
)

NB. fen to encode, fen^:_1 to decode
fen =: fen_of :. pos_of
#+end_src

#+RESULTS: fen

#+begin_src J :session :exports results :verb 0!:1
fen 'Qxd4' san 'Qxf3' san 'exf3' san 'f3' san 'Nf6' san 'Nc3' san 'dxe4' san 'd4' san 'd5' san 'e4' san start
start -: ]&.:fen start
#+end_src

#+RESULTS:
:    fen 'Qxd4' san 'Qxf3' san 'exf3' san 'f3' san 'Nf6' san 'Nc3' san 'dxe4' san 'd4' san 'd5' san 'e4' san start
: rnbqkbnr/ppp1pppp/5n2/8/3q4/2N2Q2/PPP3PP/RNBQKBNR w KQkq - 0 6
:    start -: ]&.:fen start
: 1

* Eval

Want to send positions to stockfish to analyze. Stockfish works from
something called a UCI (universal chess interface). Text in and text
out.

First command ~uci~ should be sent. Position can be set from ~position
fen <fen>~. ~go~ is used to start off an analysis. Can specify
depth/move time/others.

Some links: 
+ https://gist.github.com/aliostad/f4470274f39d29b788c1b09519e67372
  (this seems to be the UCI spec in github gist)
+ https://chess.stackexchange.com/questions/12580/working-with-uci-protocol-coding

Can use foreign ~2!:2~ to spawn stockfish. This foreign returns two
file numbers that are connected to stdin/stdout of subprocess (what
about stderr?). They can be closed by ~1!:22~ when it's all done.

On second thought, 2!:2 kinda sucks. Will use scheme for now. 


* Rating


* Final program

#+begin_src J :session :tangle chess.ijs :noweb yes
coclass 'jchess'

NB. core representation
<<basics>>

<<squares>>

<<neighborhoods>>

<<sliding-movement>>

NB. algebraic notation
<<masks>>

<<castling>>

<<disambiguation>>

<<san-monstrosity>>

NB. fen, obvi
<<fen>>

NB. pgn, obvi
<<pgn>>

<<db>>

NB. fen_z_ =: fen_jchess_
NB. print_z_ =: print_jchess_
NB. san_z_ =: san_jchess_
NB. start_z_ =: start_jchess_
#+end_src
