#+title: Chess from J
#+subtitle: idk
#+OPTIONS: author:nil num:nil
#+HTML_HEAD: <link rel="stylesheet" href="../format/css.css" />
#+HTML_HEAD: <link rel="icon" type="image/png" href="../images/icon.png" />


* Representation

** bitboard/state

Letters for pieces and a starting board. The representation:
+ 2x6 table of 8x8 bitboards for each color for each piece. The first
  item of the table represents black's position and the last item
  white's. 
+ The player's move is an index 0 or 1 into that bitboard table,
  starting at 1 for white to move.
+ Castling rights are indicated with a length four array for white's
  king & queen sides then black's king & queen sides rights.
+ En passant is represented by a column (0-7). Based on whose turn it
  is this is sufficient to determine the target square, as the only
  moves when pawn's advance by 2 are rows 2->4 or 7->5. No enpassant
  target is indicated by the number 8.
+ Half move clock is a number (the moves since last capture or pawn move).
+ Full move clock is a number that increments after moves by black.

#+name: basics
#+begin_src J :session :exports code
pieces =: 'pnbrqkPNBRQK'
piecesfr =: 'pcftdrPCFTDR'
pieces_u =: u: (i.-#pieces) + 16b2654 NB. unicode, nb width screws up boxing

board0 =: (];._2) 0 : 0
rnbqkbnr
pppppppp
........
........
........
........
PPPPPPPP
RNBQKBNR
)

start =: (_6 ]\ pieces ="0 _ board0);1;1 1 1 1;8;0;1
print =: ('.',pieces) {~ +./ @: (* 1+i.@#) @: (,/)
display =: print @: (0&{::)
i88 =: i. 8 8
#+end_src

#+RESULTS: basics

We can see the boards with the help of ~print~:

#+begin_src J :session :exports results :verb 0!:1
<"0 print 0 {:: start
#+end_src

#+RESULTS:
#+begin_example
   <"0 print 0 {:: start
┌─┬─┬─┬─┬─┬─┬─┬─┐
│r│n│b│q│k│b│n│r│
├─┼─┼─┼─┼─┼─┼─┼─┤
│p│p│p│p│p│p│p│p│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│P│P│P│P│P│P│P│P│
├─┼─┼─┼─┼─┼─┼─┼─┤
│R│N│B│Q│K│B│N│R│
└─┴─┴─┴─┴─┴─┴─┴─┘
#+end_example

** squares

~IP, ..., IK~ give some kind of enumeration of the indices for the
various piece bitboards. ~coords~ give the algebraic ascii values for
columns and rows. ~square~ takes a description for a square and
returns its index in an 8x8 grid.

#+name: squares
#+begin_src J :session :exports both
'IP IN IB IR IQ IK' =: i. 6
coords =: 97 (,:|.)&(a.{~+&(i.8)) 49
SQix =: [: |. coords&(i."1 0)
SQt =: _2 {. -.&((6}.pieces),'+#=') NB. target square of SAN move
SQ =: i88 = 8 #. SQix @: SQt
#+end_src

#+RESULTS: squares

#+RESULTS:
: abcdefgh
: 87654321

** movement

Here are neighborhoods for all the pieces, described as vectors.

#+name: neighborhoods
#+begin_src J :session :exports both
NP =: (,-) 2 0,1,.i:1 NB. pawn (both black & white)
NN =: ,/ (<:+:#:i.4) *"1/ >:=/~i.2 NB. knight
NB =: ,/ (<:+:#.^:_1 i.4) *"1/ ,~"0}.i.8 NB. bishop
NR =: (,-) (,.&0,0&,.) }. i.8 NB. rook
NQ =: NB,NR NB. queen
NK =: <: 3 #.^:_1 (i.9)-.4 NB. king
NHOOD =: NP;NN;NB;NR;NQ;NK
#+end_src

#+RESULTS: neighborhoods

For example:

#+begin_src J :session :exports results :verb 0!:1
NN NB. knight moves
<"0 ' x@' {~ NN (+:@] + +./@:(|.!.0)) SQ 'b5' NB. knight's moves from b5
#+end_src

#+RESULTS:
#+begin_example
   NN NB. knight moves
_2 _1
_1 _2
_2  1
_1  2
 2 _1
 1 _2
 2  1
 1  2
   <"0 ' x@' {~ NN (+:@] + +./@:(|.!.0)) SQ 'b5' NB. knight's moves from b5
┌─┬─┬─┬─┬─┬─┬─┬─┐
│ │ │ │ │ │ │ │ │
├─┼─┼─┼─┼─┼─┼─┼─┤
│x│ │x│ │ │ │ │ │
├─┼─┼─┼─┼─┼─┼─┼─┤
│ │ │ │x│ │ │ │ │
├─┼─┼─┼─┼─┼─┼─┼─┤
│ │@│ │ │ │ │ │ │
├─┼─┼─┼─┼─┼─┼─┼─┤
│ │ │ │x│ │ │ │ │
├─┼─┼─┼─┼─┼─┼─┼─┤
│x│ │x│ │ │ │ │ │
├─┼─┼─┼─┼─┼─┼─┼─┤
│ │ │ │ │ │ │ │ │
├─┼─┼─┼─┼─┼─┼─┼─┤
│ │ │ │ │ │ │ │ │
└─┴─┴─┴─┴─┴─┴─┴─┘
#+end_example

** Sliding Movement
#+name: sliding-movement
#+begin_src J :session :exports both
NB. n is source, m is mask of clear squares?
MV =: {{ (+. m *. y&(|.!.0))^:_ n }} NB. moves
ATK =: {{ n ~: y |.!.0 m MV n y }} NB. attacks (moves including possibly one piece)
NB. y is source square, m is movement vector, x is bit brick
NB. thus, in MV/ATK, n is source, m is clear squares, y is movement direction
M =: {{ y ~: +./ _2 (y ~: -. +./^:2 x) MV y\ m }}
A =: {{ y ~: +./ _2 (y ~: -. +./^:2 x) ATK y\ m }}
A1 =: 2 : '+./ (_2 ]\ m) |.!.0 y'
MB =: _1 _1 _1 1 1 _1 1 1 M NB. bishop
AB =: _1 _1 _1 1 1 _1 1 1 A NB. bishop
MR =: 0 _1 0 1 _1 0 1 0 M NB. rook
AR =: 0 _1 0 1 _1 0 1 0 A NB. rook
AK =: (,NK) A1 NB. king
AN =: (,NN) A1 NB. knight
MQ =: MB +. MR
AQ =: AB +. AR

NB. x ATKSMn y -- attacks from major + minor pieces in position x from color y
ATKSMm =: {{(x AN IN{y{x)+.(x AB IB{y{x)+.(x AR IR{y{x)+.(x AQ IQ{y{x)}}
#+end_src

#+RESULTS: sliding-movement

* Algebraic Notation

This a most annoying thing to get working. Chess moves are described
by giving the piece and the square it moves to. Pawns moves are
implicitly given by just the square. If only one piece can move to the
square, then the source is not indicated. If there is ambiguity then
more information about the source is given, the source file, rank, or
even the full source square if file or rank alone would still be
ambiguous.

The grammar is (roughly):

#+begin_example
piece = N | B | R | Q | K
file = a | b | c | d | e | f | g | h
rank = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8
capture = x
check = +
checkmate = #
kingattack = check | checkmate
square = file rank
promotion = '='
castle = (O-O | O-O-O) kingattack?
move = (piece? file? rank? capture? square (promotion piece)? kingattack?)
     | castle
#+end_example

** masks

As we use bitboards, here are some verbs to get masks files, ranks,
and getting the piece from a move.

The source of a bug was confusion of file b with bishop; it's
important to only look for capital letters for describing pieces in
moves.

#+name: masks
#+begin_src J :session :exports both
piece =: [: (* 6&~:) (6}.pieces) i. {.
maskf =: (8 8 $ i.8) = ({.coords)&i. NB. mask file
maskr =: (8 $"0 i.8) = ({:coords)&i. NB. mask row
maskc =: maskr`maskf@.(e.&'abcdefgh') NB. for masking eg Nbxd2 or R3a2
#+end_src

#+RESULTS: masks

** castling

#+name: castling
#+begin_src J :session :exports both
NB. x = 0 or 1 means king or queen sides resp, y is position
OO =: 4 : 0
 'brd bw oo ep hm fm' =. y
 oo =. oo * (-+:<:+:bw) |.!.0 oo
 k =. i88 = (56*bw)+6-4*x
 r =. i88 e. (56*bw)+(5*-.x),(7-x*4)
 rm =. r ~: (<bw,IR) { brd
 brd =. (k,:rm)((<bw,IK),(<bw,IR))}brd
 brd;(-.bw);oo;ep;(hm+1);(fm+-.bw)
)
O_O_O =: 1&OO
O_O =: 0&OO
OO_sqs =: _2<@SQix\'h1e1a1h8e8a8' NB. castling squares, used to detect
				  NB. when castling rights are lost.
#+end_src

#+RESULTS: castling

** SAN mostrosity

The following mostrosity takes a move and a position and produces a
new position. Little error checking is currently done, it is (for the
moment) assumed the input pgn/move/state is valid and consistent.

#+name: san-monstrosity
#+begin_src J :session :exports both
NB. have a target square, figure out which piece can get there.
san =: 4 : 0
 if. 'O-O-O' -: 5{.x   do. O_O_O y NB. {. to avoid possible +/#
 elseif. 'O-O' -: 3{.x do. O_O y
 else.
   p =. piece x
   'brd bw oo ep hm fm' =. y
   brd0 =. brd
   NB. to : where piece will be
   to =. i88 = 8 #. xy =. SQix d =. _2 {. z =. x -. (6}.pieces),'x+#='
   if. p NB. non pawn move
   do. select. p
     case. IN do. src =. ((<bw,p){brd)*.(*./maskc _2}.z)*.brd AN to
     case. IB do. src =. ((<bw,p){brd)*.(*./maskc _2}.z)*.brd AB to
     case. IR do. src =. ((<bw,p){brd)*.(*./maskc _2}.z)*.brd AR to
     case. IQ do. src =. ((<bw,p){brd)*.(*./maskc _2}.z)*.brd AQ to
     case. IK do. src =. ((<bw,p){brd)*.(*./maskc _2}.z)*.brd AK to end.
     if. p do.
       if. 1 < +/,src do. NB. need to disambiguate (discovered pinned
                          NB. checks are the problem, but i'm sure other
                          NB. edge cases will pop up)
         for_s. (i88 =/~ I.@:,) src do. NB. try each possible move
           brd =. ((-.s)*.to+.(<bw,p){brd0) (<bw,p)} brd0*."2-.to+.s
           NB. need to check current color's king not left in check
           if. 0 = +./,((<bw,IK){brd) *. brd ATKSMm -.bw do. break. end.
         end.
       else.
         brd =. ((-.src)*.to+.(<bw,p){brd0) (<bw,p)} brd0*."2-.to+.src
       end.
       ep =. 8
       oo =. oo*-.,_3(2+./\])\OO_sqs{+./^:2 brd~:brd0
     end.
   else. NB. pawn move
     dz =. 0,~<:+:bw
     ept =. ep ,~ 2 + 3 * 1 - bw NB. en passant target index
     NB. simple pawn moves, also need to do captures & promotions
     if. 'x' e. x NB. if capture
     do. src =. i88 = 8 #. dz+({.xy),({.coords)i.{.z NB. source
         NB. square extra clear bit in case en passant for captured
         NB. pawn
         capenp =. (xy-:ept) *. i88 = 8#.xy+dz 
         brd =. ((-.src)*.to+.(<bw,p){brd) (<bw,p)} brd*."2-.to+.src+.capenp
         ep =. 8 NB. no en passant when capturing
     else.
      is2 =. -.(<bw,0,dz+xy){brd NB. if no pawn was a 2 step move
      epc =. *./ , to *. +./ _1 1 |.!.0"0 1/ (<(-.bw),IP){brd
      src =. i88 = 8#.xy+dz+is2*dz NB. source square
      ep =. (epc*.is2){8,{:xy NB. en passant if moved 2 on file ({:xy), else 8
      brd =. ((-.src)*.to+.(<bw,p){brd) (<bw,p)} brd*."2-.src
     end.
     if. '=' e. x NB. promotion
     do. brd=.(to+.pix{brd) (pix=.<bw,piece{:x-.'+#x')} (-.to)*."2 brd
     end.
   end.
   fm =. fm+-.bw [ hm =. (hm+1) * -. (-.({.x)e.pieces) +. ('x'e.x)
   brd;(-.bw);oo;ep;hm;fm
 end.
)
#+end_src

#+RESULTS: san-monstrosity

For example some Blackmar-Diemer-Ryder:

#+begin_src J :session :exports results :verb 0!:1
<"0 print 0 {:: 'Qxd4' san 'Qxf3' san 'exf3' san 'f3' san 'Nf6' san 'Nc3' san 'dxe4' san 'd4' san 'd5' san 'e4' san start
#+end_src

#+RESULTS:
#+begin_example
   <"0 print 0 {:: 'Qxd4' san 'Qxf3' san 'exf3' san 'f3' san 'Nf6' san 'Nc3' san 'dxe4' san 'd4' san 'd5' san 'e4' san start
┌─┬─┬─┬─┬─┬─┬─┬─┐
│r│n│b│.│k│b│.│r│
├─┼─┼─┼─┼─┼─┼─┼─┤
│p│p│p│.│p│p│p│p│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│n│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│.│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│.│q│.│.│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│.│.│N│.│.│Q│.│.│
├─┼─┼─┼─┼─┼─┼─┼─┤
│P│P│P│.│.│.│P│P│
├─┼─┼─┼─┼─┼─┼─┼─┤
│R│.│B│.│K│B│N│R│
└─┴─┴─┴─┴─┴─┴─┴─┘
#+end_example

* PGN

Need to figure out all what I'd like to be able to do with pgns, but
for now we can take the move part of the PGN and get all the positions
of a game.

#+name: pgn
#+begin_src J :session :exports both
del_brak =: ] #~ 0 = [: (+. _1&(|.!.0)) [: +/\ (-/@:(=/))
del_com =: (-.&'?!')&.>
del_num =: #~ ('.' ~: {:)&>
pgn_clean =: {{ '()' del_brak '{}' del_brak ' ' (I. LF=y)} y }}
pgn_nonmoves =: a:,'1-0';'0-1';'1/2-1/2'
pgn_moves =: {{ del_num del_com (<;._1 ' ',pgn_clean y) -. pgn_nonmoves }}

NB. x =. x -. '?! ' NB. remove move quality commentary
NB. take pgn movetext and build all states of game
game_of_pgn =: 3 : 0
 moves =. pgn_moves y
 fens =. < brd =. start
 for_move. moves do.
   fens =. fens,<brd =. (>move) san brd
 end.
)

NB. take pgn movetext and return final position
final_of_pgn =: 3 : 0
 for_move. moves =. pgn_moves y [ brd =. start do. brd =. (>move) san brd end. brd
)

pgn_key =: > @: {. @: (<;._1)~ '[ '&(+./ @: (=/)) NB. pgn symbol token
pgn_val =: #~ [: (~:/\ * 0&=) '"'&= NB. pgn string token
pgn_db =: <;.1~ '[Event'&E.
pgn_moves_sec =: I. @: ((LF,'1.')&E.)

ppgn =: 3 : 0
NB. remove abandoned?
 j =. {. (<:#y),~pgn_moves_sec y=.y,LF
 tagpairs =. (pgn_key;pgn_val);._2 j {. y
 movetext =. (j }. y) -. LF
 tagpairs ; movetext
)
#+end_src

#+RESULTS: pgn

* DB

#+name: db
#+begin_src J :session :exports both

#+end_src

* FEN

It's (clearly) useful to be able to input and output postions in FEN
format. FEN encodes positions with a string describing the board rank
by rank, from the 8th forward separated by ~/~, with lower case for
black, upper case for white, and empty space encoded by the number of
consecutive empty squares. Turn is indicated by ~b | w~, castling
rights by ~KQkq~. There is a possible en passant target square, and
lastly half moves & full moves. The absence of castling rights or en
passant squares is given by ~-~.

#+name: fen
#+begin_src J :session :exports both
NB. FEN helpers
rleb =: (0&{::#1&{::)`([:":0&{::)@.('.'-:1&{::)
rldb =: ]`('.'#~".)@.(e.&({:coords))
rle =: ([: < [: rleb (#;{.));.1~ 1,2 ~:/\ ]
rld =: [: ([:;<@rldb"0);._1 '/',]
efen =: [: > [: (([,'/',])&.>)/ [: <@;@rle"1 print
dfen =: (_6]\i.#pieces) =/ pieces i. rld

fen_of =: 3 : 0
 NB. fen from our representation
 'brd bw oo ep hm fm' =. y
 oo =. (0<+/oo){::'-';oo#'KQkq'
 ep =. (ep~:8){::'-';(ep{({.coords),'-'),(bw{'36')
 ;:^:_1 (efen brd);(bw{'bw');oo;ep;hm;&":fm
)

pos_of =: 3 : 0
 NB. our representation from a fen
 'brd bw oo ep hm fm' =. <;._1 ' ',y
 NB. careful that bw isn't array?
 (dfen brd);('w'={.bw);('KQkq'e.oo);({:(SQix :: 8:)ep);hm;&".fm
)

NB. fen to encode, fen^:_1 to decode
fen =: fen_of :. pos_of
#+end_src

#+RESULTS: fen

#+begin_src J :session :exports results :verb 0!:1
fen 'Qxd4' san 'Qxf3' san 'exf3' san 'f3' san 'Nf6' san 'Nc3' san 'dxe4' san 'd4' san 'd5' san 'e4' san start
start -: ]&.:fen start
#+end_src

#+RESULTS:
:    fen 'Qxd4' san 'Qxf3' san 'exf3' san 'f3' san 'Nf6' san 'Nc3' san 'dxe4' san 'd4' san 'd5' san 'e4' san start
: rnbqkbnr/ppp1pppp/5n2/8/3q4/2N2Q2/PPP3PP/RNBQKBNR w KQkq - 0 6
:    start -: ]&.:fen start
: 1

* Eval

Want to send positions to stockfish to analyze. Stockfish works from
something called a UCI (universal chess interface). Text in and text
out.

First command ~uci~ should be sent. Position can be set from ~position
fen <fen>~. ~go~ is used to start off an analysis. Can specify
depth/move time/others.

Some links: 
+ https://gist.github.com/aliostad/f4470274f39d29b788c1b09519e67372
  (this seems to be the UCI spec in github gist)
+ https://chess.stackexchange.com/questions/12580/working-with-uci-protocol-coding

Can use foreign ~2!:2~ to spawn stockfish. This foreign returns two
file numbers that are connected to stdin/stdout of subprocess (what
about stderr?). They can be closed by ~1!:22~ when it's all done.

On second thought, 2!:2 kinda sucks. Will use scheme for now. 


* Rating


* Final program

#+begin_src J :session :tangle chess.ijs :noweb yes
coclass 'jchess'

NB. core representation
<<basics>>

<<squares>>

<<neighborhoods>>

<<sliding-movement>>

NB. algebraic notation
<<masks>>

<<castling>>

<<san-monstrosity>>

NB. fen, obvi
<<fen>>

NB. pgn, obvi
<<pgn>>

<<db>>

NB. fen_z_ =: fen_jchess_
NB. print_z_ =: print_jchess_
NB. san_z_ =: san_jchess_
NB. start_z_ =: start_jchess_
#+end_src
